dig.dot = {};
dig.dot.alg = {};

var dig_dot_write = dig.dot.write = (function() {
  function id(obj) {
    return '"' + obj.toString().replace('"', '\\"') + '"';
  }

  return function(graph) {
    var edgeConnector = graph.isDirected() ? "->" : "--";
    var str = (graph.isDirected() ? "digraph" : "graph") + " {\n";

    dig_util_forEach(graph.nodes(), function(v) {
      str += "    " + id(v);
      var label = graph.nodeLabel(v);
      if (label !== undefined) {
        str += ' [label="' + label + '"]';
      }
      str += ";\n";
    });

    dig_util_forEach(graph.edges(), function(e) {
      str += "    " + id(e.from) + " " + edgeConnector + " " + id(e.to);
      var label = graph.edgeLabel(e.from, e.to);
      if (label !== undefined) {
        str += ' [label="' + label + '"]';
      }
      str += ";\n";
    });

    str += "}\n";
    return str;
  };
})();

var dig_dot_read = dig.dot.read = function(dot) {
  var parseTree = dig_dot_parser.parse(dot);
  var graph = parseTree.type === "digraph" ? new dig.DiGraph() : new dig.UGraph();

  function handleStmt(stmt) {
    switch (stmt.type) {
      case "node":
        var id = stmt.id;
        var label = stmt.attrs.label;
        graph.addNode(id);
        graph.nodeLabel(id, label);
        break;
      case "edge":
        var prev;
        dig_util_forEach(stmt.elems, function(elem) {
          handleStmt(elem);

          switch(elem.type) {
            case "node":
              if (prev) {
                graph.addEdge(prev, elem.id, stmt.attrs.label);
              }
              prev = elem.id; 
              break;
            default:
              // We don't currently support subgraphs incident on an edge
              throw new Error("Unsupported type incident on edge: " + elem.type);
          }
        });
        break;
      case "attr":
        // Ignore attrs
        break;
      default:
        throw new Error("Unsupported statement type: " + stmt.type);
    }
  }

  dig_util_forEach(parseTree.stmts, function(stmt) {
    handleStmt(stmt);
  });
  return graph;
}

// Given a directed graph this function will transform the graph in place into
// a directed acyclic graph (DAG) by reversing edges that participate in
// cycles. This algorithm currently just uses a basic DFS traversal.
//
// This algorithm does not preserve labels for reversed edges.
var dig_dot_alg_acyclic = dig.dot.alg.acyclic = function(g) {
  var onStack = {};
  var visited = {};

  function dfs(u) {
    if (u in visited) {
      return;
    }
    visited[u] = true;
    onStack[u] = true;
    dig_util_forEach(g.successors(u), function(v) {
      if (v in onStack) {
        if (!g.hasEdge(v, u)) {
          g.addEdge(v, u);
        }
        g.removeEdge(u, v);
      } else {
        dfs(v);
      }
    });
    delete onStack[u];
  }

  dig_util_forEach(g.nodes(), function(u) {
    dfs(u);
  });
}

// For now we use a BFS algorithm to assign ranks. This algorithm requires
// at least one source and requires that all nodes are reachable from the
// graph sources (i.e. no strongly connected components).
//
// This algorithm modifies the supplied graph in place.
//
// TODO support weighted edges
var dig_dot_alg_initRank = dig.dot.alg.initRank = function(g) {
  var ranks = dig_alg_levels(g, g.sources());

  // Make sure we visited everything
  var visitCount = 0;
  dig_util_forEach(dig_util_objToArr(ranks), function() { ++visitCount; });

  if (visitCount != g.order()) {
    throw new Error("One or more strongly connected components in the input graph: " + g);
  }

  dig_util_forEach(dig_util_objToArr(ranks), function(u) {
    g.nodeLabel(u, ranks[u]);   
  });
}
